I want to build a procedural 2d background layer objects generation system. Here's the idea:
1. There will be a set of areas representing a particular biome. Each area is represented as a state in a state machine. An Area State itself has an internal graph to keep track of internal sub area relationships, more on that later. Each area has a generate method. The state machine should also have the same method and delegate this call to the currently active state. The generate method should return an array of objects (details incoming). The current area should define which states it can transition to as an array that looks like this: { area: Area_Constructor_Name, weight: number }[]. It should also have a helper method that helps us add an entry to this transition array, taking name as first arg and weight as second. Each area should have a transition method, which computes transition area constructor name, and calls transition method on parent.
2. Like mentioned before, each area will keep track of sub area graph. Such sub graph will itself  have addNodes (add all possible nodes at once) and addEdge methods to help define sub area adjacency relationships. nodes are just strings. And add edge method supports 4 params, first two are src and dest nodes, third is gap defaluts to 0, and fourth is weight which defaults to 1. There are setInitialNode and setTerminalNode methods in the graph to help identify start and end points. There can be multiple starting or end points. This graph will take in dimsMap parameter initially, which is an object that maps the node name to it's width and height, along with height we mentioned earlier.This graph will have next method. What next will do is return null if current node is terminal node, and sets next node to be undefined. If current node is undefined, it sets current node to initial node and returns an object with node name and gap (set in addEdge method). In any other case, it'll search for next node (one of edges of current node), and returns the next node along wit gap, setting next node to be current. Oh, and the non null return values of next also should contain dims entry which is just dimsMap[name] for the currently selected node name. Initially currentNode is set to undefined.
3. Let's now get into the generate method of Area state. This generate method should call next method on it's sub area graph and receive name, gap and dims of the current sub area. Area state will also have height field that gives it's height information which defaults to 1. Height is a quantized value and it is how many height tiles should go below the current area tiles. With these four pieces of information, we can construct an array of objects to return from generate method that we alluded to. Thiese objects are just tiles with these fileds: t, x, y, where t is tile name. To compute that, assume that the we grow tiles from bottom up in literal sense and that the bottom starts at zero with y values going negative as we go up. So if the area has height=1, baseTile dimensions are w=48 h=64, and we need 2 base tiles to support newly generated subarea or tile, then we will generate 2 base tiles: { t: "base", x: stateMachine.curX, y: -64 } and {t:"base", x: stateMachine.curX + 48, y: -64}. Then we will add to that newly generated sub tile, x is curX, y is -dims.h - height * baseHeight(=64). The way we determine the number of bases along x axis is by adding dims.w with gap, and computing the minimum number of bases necessary to support that much width. Before returning we also set stateMachine's curX to curX + num_of_bases_in_generated_in_x * baseWidth(=48). Also in case null is returned by sub area graph next method, we simply call transition method and return the call to stateMachines generate method.